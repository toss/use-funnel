import { Steps, Callout } from 'nextra/components'
import { UseFunnelCodeBlock, Keyword } from '@/components'

# 사용방법

<Steps>
### 먼저 각 <Keyword keyword="step" /> 별로 필요한 <Keyword keyword="context" /> 를 정의해요.
    
```tsx filename="context.ts"
// 1. 아무것도 입력 안됨
type 이메일입력 = { email?: string; password?: string; other?: unknown }
// 2. 이메일은 입력됨
type 비밀번호입력 = { email: string; password?: string; other?: unknown }
// 3. 이메일과 비밀번호 입력됨
type 그외정보입력 = { email: string; password: string; other?: unknown }
```
    
### <Keyword keyword="step" /> 을 key로 한 <Keyword keyword="context" /> 객체를 `useFunnel(){:jsx}` 의 제네릭으로 지정해주세요.
    
해당 컴포넌트에 진입했을때 사용할 <Keyword keyword="step" /> 과 <Keyword keyword="context" /> 객체를 `initial`에 지정해주세요.

<UseFunnelCodeBlock>
```tsx /funnel/
import { useFunnel } from "@use-funnel/next";
import type { 이메일입력, 비밀번호입력, 그외정보입력 } "./context";

function MyFunnelApp() {
  const funnel = useFunnel<{
    이메일입력: 이메일입력;
    비밀번호입력: 비밀번호입력;
    그외정보입력: 그외정보입력;
  }>({
    id: "my-funnel-app",
    initial: {
      step: "이메일입력",
      context: {}
    }
  });
  // ...
}
```
</UseFunnelCodeBlock>

<Callout type="info">`id` 는 [한 컴포넌트에 여러 퍼널](/docs/sub-funnel)이 있을 때, 유니크하게 구분할 수 있는 값이에요.</Callout>
<Callout>이 방법 이외의 <Keyword keyword="step" /> 별 상태 정의는 [상태 정의 가이드](/docs/context-guide)를 참고해주세요.</Callout>
    
### `useFunnel(){:jsx}` 에서 반환된 `step` 에 따라 `context`, `history` 를 사용해요.

```tsx /funnel/
declare function 이메일입력(props: { onNext: (email: string) => void }): JSX.Element;
declare function 비밀번호입력(props: { email: string; onNext: (password: string) => void }): JSX.Element;
declare function 그외정보입력(): JSX.Element;

switch (funnel.step) {
  case '이메일입력':
    return <이메일입력 onNext={(email) => funnel.history.push('비밀번호입력', { email })} />;
  case '비밀번호입력':
    return (
      <비밀번호입력
        email={funnel.context.email} // 이메일 입력에서 입력했기 때문에 undefined가 아니에요!
        onNext={(password) => funnel.history.push('그외정보입력', { password })}
      />
    );
  case '그외정보입력':
    return <그외정보입력 />;
}
```

- `funnel.context{:jsx}` 를 통해 현재 <Keyword keyword="step" /> 의 <Keyword keyword="context" /> 를 가져올 수 있어요. `funnel.step{:jsx}` 값에 따라 `funnel.context{:jsx}` 의 타입이 <Keyword keyword="step" /> 별로 정의한 타입으로 추론돼요.
  - <Callout>위 예제를 보면, "이메일입력" 에서 `funnel.context.email` 은 `string | undefined` 타입이지만, "비밀번호입력" 에서 `funnel.context.email` 은 `string` 타입으로 추론돼요.</Callout>
- `funnel.history.push(){:jsx}` 를 통해 다음 단계로 넘어갈 수 있어요. 첫번째 인자로 <Keyword keyword="step" /> 을, 두번째 인자로 해당 <Keyword keyword="step" /> 으로 진입하기 위해 필요한 <Keyword keyword="context" /> 를 받아요.
- `funnel.history.replace(){:jsx}` 는 `funnel.history.push()` 와 기본적인 동작은 같지만, 히스토리를 쌓지 않고 현재 <Keyword keyword="step" /> 을 덮어씌워요.

    
혹은 `useFunnel(){:jsx}` 에서 반환되는 `<Render />{:jsx}` 컴포넌트를 사용할 수 있어요. 해당 컴포넌트의 자세한 사용방법은 [여기](/docs/funnel-render)를 참고해주세요.

```tsx /funnel/
return (
  <funnel.Render
    이메일입력={({ history }) => (
      <이메일입력 onNext={(email) => history.push('비밀번호입력', { email })} />
    )}
    비밀번호입력={({ context, history }) => (
      <비밀번호입력
        email={context.email}
        onNext={(password) => history.push('그외정보입력', { password })}
      />
    )}
    그외정보입력={() => <그외정보입력 />}
  />
)
```
</Steps>