import { Callout } from 'nextra/components'
import { Keyword, UseFunnelCodeBlock } from '@/components'

# `<funnel.Render />`

`useFunnel(){:jsx}` 에서 반환되는 `<Render />{:jsx}` 컴포넌트를 통해 각 <Keyword keyword="step" /> 의 렌더링을 간단하게 정의할 수 있어요. 또한 이벤트를 정의하거나 오버레이 기능 등을 사용할 수 있어요.

<UseFunnelCodeBlock>
```tsx /funnel.Render/
import { useFunnel } from "@use-funnel/next";

const funnel = useFunnel(/* ... */);
return (
  <funnel.Render
    이메일입력={({ history }) => (
      <이메일입력 onNext={(email) => history.push('비밀번호입력', { email })} />
    )}
    비밀번호입력={({ context, history }) => (
      <비밀번호입력
        email={context.email}
        onNext={(password) => history.push('그외정보입력', { password })}
      />
    )}
    그외정보입력={() => <그외정보입력 />}
  />
)
```
</UseFunnelCodeBlock>

각 <Keyword keyword="step" /> 에 해당하는 렌더링 함수를 `<Render />{:jsx}` 컴포넌트의 props로 넘겨줍니다. 해당 렌더링 함수의 인자로 `funnel` 객체가 들어가며, 해당 <Keyword keyword="step" /> 에 맞는 `context`, `history` 에 접근할 수 있어요.

## 전환 이벤트 정의하기

현재 <Keyword keyword="step" /> 에서 여러 개의 경로가 필요할 때 이벤트를 정의해서 사용하는 것을 고려해볼 수 있어요.
    
```tsx /events/
<funnel.Render
  이메일입력={funnel.Render.with({
    events: {
      이메일입력완료: (email: string, { history }) => history.push('비빌번호입력', { email }),
      이메일입력실패: (error: Error, { history }) => history.push('에러페이지', { error: error.message })
    },
    render({ context, dispatch }) {
      return (
        <이메일입력
          email={context.email}
          onNext={(email) => dispatch('이메일입력완료', email)}
          onError={(error) => dispatch('이메일입력실패', error)}
        />
      )
    }
  })}
/>
```

이벤트 객체를 포함하는 렌더링 객체는 다음과 같은 타입을 가지고 있어요.

```ts
interface FunnelRenderWithEvent<
  TEvents extends {
    [eventName: string]: (payload: any, context: FunnelRenderContext) => void
  },
  TEventDispatch extends {
    [eventName in keyof TEvents]: (payload: Parameters<TEvents[eventName]>[0]) => void
  }[keyof TEvents]
> {
  events: TEvents,
  render: (props: { context: Context; dispatch: TEventDispatch }) => React.ReactNode
}
```

이벤트를 정의할 경우, 렌더링 함수에서 `history` 를 사용하지 못해요. 대신에 `events` 객체를 통해 정의한 이벤트를 `dispatch(){:jsx}` 함수를 통해 호출할 수 있어요.

이벤트 객체의 키가 이벤트 이름이 되어 `dispatch(){:jsx}` 함수의 첫번째 인자로 전달되고, 두번째 인자로는 이벤트 객체에 정의된 함수의 첫번째 인자가 전달돼요.

<Callout>
  현재 단계에서 발생할 수 있는 경로들을 한번에 정의할 수 있어, 응집력 있는 코드를 기대할 수 있어요.
</Callout>

## Overlay

현재 단계에서 이전 단계를 유지한채 모달, 바텀시트와 같은 UI를 표현하고자 할 때 사용할 수 있어요.
        
```tsx /overlay/
<funnel.Render
  이메일입력={({ history }) => (
    <이메일입력
      onNext={(email) => history.push('약관동의', { email })}
    />
  )}
  약관동의={funnel.Render.overlay({
    render({ history }) {
      return <약관동의 onAgree={() => history.push('비밀번호입력')} />
    }
  })}
/>
```
        
이 경우 `<약관동의/>{:jsx}` 컴포넌트가 렌더링 될 때, `<이메일입력/>{:jsx}` 컴포넌트 아래에 위치하게 돼요.

<Callout type="warning">
주의할점: overlay가 라우터의 뒤로가기를 통해 닫힌게 아닌 다른 인터렉션으로 닫힌 경우, 명시적으로 render 함수 인자의 `close(){:jsx}` 를 실행해줘야해요. `close(){:jsx}` 를 실행하게 될 경우, 히스토리에서 이전 단계로 이동하게돼요.
</Callout>
            
```tsx /close/
funnel.Render.overlay({
  render({ history, close }) {
    return <약관동의 onAgree={() => history.push('비밀번호입력')} onClose={() => close()} />
  }
})
```

overlay와 event를 같이 사용하고 싶다면, `funnel.Render.with(){:jsx}` 에서 `overlay: true` 를 넘겨주면 돼요.

```tsx
<funnel.Render
  이메일입력={funnel.Render.with({
    overlay: true,
    events: {
      이메일입력완료: (email: string, { history }) => history.push('비밀번호입력', { email }),
      이메일입력실패: (error: Error, { history }) => history.push('에러페이지', { error: error.message })
    },
    render({ context, dispatch }) {
      return (
        <이메일입력
          email={context.email}
          onNext={(email) => dispatch('이메일입력완료', email)}
          onError={(error) => dispatch('이메일입력실패', error)}
        />
      )
    }
  })}
/>
```